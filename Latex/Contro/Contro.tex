\documentclass[italian]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage[a4paper,top=3cm,bottom=3cm,left=2.5cm,right=2.5cm]{geometry}
\usepackage[italian]{babel}
\usepackage{listings} %Per inserire codice
\usepackage[usenames]{color} %Per permettere la colorazione dei caratteri 
%Define the listing package
\usepackage{listings} %code highlighter
\usepackage{color} %use color
\usepackage{graphicx}
\graphicspath{ {./images/} }
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

%Customize a bit the look
\lstset{ %
	backgroundcolor=\color{white}, % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
	basicstyle=\footnotesize, % the size of the fonts that are used for the code
	breakatwhitespace=false, % sets if automatic breaks should only happen at whitespace
	breaklines=true, % sets automatic line breaking
	captionpos=b, % sets the caption-position to bottom
	commentstyle=\color{mygreen}, % comment style
	deletekeywords={...}, % if you want to delete keywords from the given language
	escapeinside={\%*}{*)}, % if you want to add LaTeX within your code
	extendedchars=true, % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
	frame=single, % adds a frame around the code
	keepspaces=true, % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
	keywordstyle=\color{blue}, % keyword style
	% language=Octave, % the language of the code
	morekeywords={*,...}, % if you want to add more keywords to the set
	numbers=left, % where to put the line-numbers; possible values are (none, left, right)
	numbersep=5pt, % how far the line-numbers are from the code
	numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
	rulecolor=\color{black}, % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
	showspaces=false, % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
	showstringspaces=false, % underline spaces within strings only
	showtabs=false, % show tabs within strings adding particular underscores
	stepnumber=1, % the step between two line-numbers. If it's 1, each line will be numbered
	stringstyle=\color{mymauve}, % string literal style
	tabsize=2, % sets default tabsize to 2 spaces
	title=\lstname % show the filename of files included with \lstinputlisting; also try caption instead of title
}
%END of listing package%

\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

%define Javascript language
\lstdefinelanguage{JavaScript}{
	keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}

\lstset{
	language=JavaScript,
	extendedchars=true,
	basicstyle=\footnotesize\ttfamily,
	showstringspaces=false,
	showspaces=false,
	numbers=left,
	numberstyle=\footnotesize,
	numbersep=9pt,
	tabsize=2,
	breaklines=true,
	showtabs=false,
	captionpos=b
}
\author{
	Daniele Rigon - 857319 \\
}

\begin{document}
\title{Tesi - Contro API}
\maketitle

\tableofcontents
\pagebreak
\section{Geolocation}
\begin{itemize}
\item viene chiesto all'utente il permesso per usare l'api (unica forma di sicurezza)
\item i metodi getCurrentPosition e WatchPosition danno la posizione dell'utente. Possono essere intercettati (?) -> esempio di come prendo la posizione dell'utente (?)
\end{itemize}

\section{PaymentRequest}
\begin{itemize}
\item Usando questa API essa chiama la gestione delle credenziali del browser, caricando una finestra, e quindi non inserendo le credenziali nel DOM
\\
Su Chrome i dati inseriti sono gestiti dalla compilazione automatica di google \url{chrome://settings/autofill} -> sicuro
\\
Su Edge viene usato Microsoft Pay (prima collegandosi all'account Microsoft) -> sicuro 
\item Non ci sono metodi che prendono la password o le credenziali, vengono gestiti altrove, non si possono intercettare -> sicuro
\item può essere aperta una sola pagina con l'API per volta, altrimenti la creazione dell'oggetto PaymentRequest non andrà a buon fine 
\end{itemize}

\section{ServiceWorker}
\begin{itemize}
\item lavora solo su https o localhost, no http o file://
\\
Usando i ServiceWorker si possono dirottare le connessioni, rispondere in modo diverso a certe richieste e filtrare le risposte. Mentre  si usano questi mezzi in modo benevolo, un man-in-the-middle potrebbe usarli per altri scopi. Per evitare ciò si possono registrare i ServiceWorker solo nelle pagine HTTPS, cosi sappiamo che il ServiceWorker non è stato manomesso durante il suo viaggio attraverso la rete. Se non in localhost o https il ServiceWorker non viene registrato-installato-eseguito.
\item intercetta le richieste http (puo essere usato male?), puo fare caching ma anche altro. Come viene usato in modo malevolo intercettando dati sensibili?
\item sincronizzazione background (contro?)
\end{itemize}

\section{Scenari}
\begin{itemize}
\item Geolocation: al "si" dell'utente viene rubata la posizione tramite Geolocation API;
\\
\item PaymentRequest: vedere se ci sono metodi con i quali si può rubare il numero di carta o altre info con PaymentRequest (poco probabile perchè viene usata la gestione delle credenziali Microsoft e Google) -> capire qual è la pagina di "pop-up"(che non è un pop-up) che viene aperta;
\\
vedere se si puo caricare una pagina finta sopra per far si che siamo convinti di comprare una cosa invece compriamo altro (phishing)
\\
\item ServiceWorker: /*ServiceWorker usato non per caching ma per intercettare un messaggio, cambiandolo in negativo (simile a man-in-the-middle).*/
\\
- Attaccante carica su una pagina fb (o un altro sito) uno script js: vedere se può prendere le password e portarle fuori.
\\
- Pro: vedere se i SW possono migliorare la sicurezza di una pagina, senza essere usati solo per fare caching.
\\
- Spiegare bene il discorso degli scope.
Vedere se si possono caricare SW solo dalla stessa origine, in quel caso non possiamo caricare SW su fb da un'altra pagina, ma possiamo caricarli solo da fb.
\\
%https://chromium.googlesource.com/chromium/src/+/lkcr/docs/security/service-worker-security-faq.md
\textbf{I Service Worker obbediscono alla politica della stessa origine?}
\\
La registrazione dei Service Worker specifica che i Service Worker devono essere eseguiti nella stessa origine dei loro chiamanti.

Il confronto dell'origine per la ricerca di una registrazione di Service Worker per una richiesta viene specificato per essere una corrispondenza con prefisso più lungo degli URL serializzati, compreso il percorso. (Es. https://example.com/! = https://example.com.evil.com/.) 
Questo gap di specifiche ci sembra fragile e dovrebbe essere fissato per essere specificato e implementato come effettiva parità di origine , ma al momento non sembra sfruttabile.

Solo i contesti protetti possono registrarsi o utilizzare i Service Worker.

Poiché i SW possono chiamare importScripts per importare script (da qualsiasi altra origine), è una buona idea per gli operatori del sito impostare un'intestazione di risposta Content-Security-Policy sulla risposta JavaScript di ServiceWorker, istruendo il browser su quali fonti di script l'origine considera attendibili. Ciò ridurrebbe la capacità di un attaccante XSS di inserire il proprio codice.
\\
-
\textbf{Se un sito ha una vulnerabilità XSS, l'autore dell'attacco può compromettere definitivamente tale origine per me?}
\\
Un attaccante XSS può effettivamente registrare un SW malvagio. Come prima dei SW, XSS è una modalità di attacco molto potente su un'origine web. Per mitigare il rischio che un attacco XSS registri un SW malevolo, il browser richiede che l'URL di registrazione SW provenga dall'origine stessa. Pertanto, per utilizzare un attacco XSS per registrare un SW malevolo, l'utente malintenzionato ha bisogno della capacità aggiuntiva di ospitare i propri script sul server.

Ecco un altro scenario di exploit: se la pagina con una vulnerabilità XSS ha anche un endpoint JSONP, l'utente malintenzionato potrebbe utilizzarlo per (1) bypassare CSP; (Cryptographic Service Provider – libreria software sviluppata da Microsoft) (2) registrare un SW; e (3) chiamata importScripts per importare uno script di terze parti da conservare fino a che:
\begin{itemize}
\item gli operatori del sito rilevano e risolvono il problema; 
\item gli utenti navigano di nuovo sul sito mentre sono online.
\end{itemize}
In una situazione XSS, il limite della direttiva cache di 24 ore garantisce che un SW malevolo o compromesso sopravviverà a una correzione della vulnerabilità XSS di un massimo di 24 ore (presupponendo che il client sia online). Gli operatori del sito possono ridurre la finestra di vulnerabilità impostando TTL più bassi sugli script SW.
\\
- Vedere se ci sono metodi che limitano alcune funzionalita per mitigare questi problemi.
\end{itemize}

\section{Crawler}
Chi usa, e come:
\begin{itemize}
\item Geolocation
\item PaymentRequest
\item ServiceWorker -> principalmente questo e come lo usano
\end{itemize}
\end{document}