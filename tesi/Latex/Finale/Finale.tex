\documentclass[11pt ,a4paper , twoside , openright ]{article}
\usepackage{layouts}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage[a4paper,top=3cm,bottom=3cm,left=2.5cm,right=2.5cm]{geometry}
\usepackage[square,numbers]{natbib}
\bibliographystyle{abbrvnat}
\usepackage[italian]{babel}
\usepackage[usenames]{color} 
\usepackage{listings} 
\usepackage{color}
\usepackage{graphicx}
\usepackage[bottom]{footmisc}
\graphicspath{ {./images/} }
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\usepackage{tikz} % for background logo in frontespizio
\addtolength{\skip\footins}{3pc plus 5pt}
\renewcommand{\arraystretch}{1.5}
\pagestyle{plain}



\titleformat{\chapter}[display]
{\Huge\bfseries}
{}
{0pt}
{\thechapter.\ }

\titleformat{name=\chapter,numberless}[display]
{\Huge\bfseries}
{}
{0pt}
{}

\lstset{ 
	backgroundcolor=\color{white}, 
	basicstyle=\footnotesize,
	breakatwhitespace=false, 
	breaklines=true,
	captionpos=b, 
	commentstyle=\color{mygreen}, 
	escapeinside={\%*}{*)}, 
	extendedchars=true, 
	frame=single,
	keepspaces=true, 
	keywordstyle=\color{blue},
	morekeywords={*,...}, 
	numbers=left, 
	numbersep=5pt, 
	numberstyle=\tiny\color{mygray}, 
	rulecolor=\color{black}, 
	showspaces=false, 
	showstringspaces=false, 
	showtabs=false, 
	stepnumber=1, 
	stringstyle=\color{mymauve}, 
	tabsize=2, 
}

\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
	keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}

\lstset{
	language=JavaScript,
	extendedchars=true,
	basicstyle=\small\ttfamily,
	showstringspaces=false,
	showspaces=false,
	numbers=left,
	numberstyle=\scriptsize,
	numbersep=9pt,
	tabsize=2,
	breaklines=true,
	showtabs=false,
	captionpos=b
}

\author{
	Daniele Rigon - 857319 \\
}


\pagestyle{plain}
\author{Daniele Rigon}
\title{Tesi}
\makeindex
\usepackage{titlesec}

\titleformat{\chapter}[display]
{\Huge\bfseries}{}{0pt}{\thechapter.\ }
\titleformat{name=\chapter,numberless}[display]
{\Huge\bfseries}{}{0pt}{}

\begin{document}
	\thispagestyle{empty}
	\begin{tikzpicture}[remember picture,overlay]
	\node[inner sep=0pt,anchor=0,opacity=0.5]{\includegraphics{CaFoscariLogo.png}};
	\node[inner sep=40pt,anchor=45,opacity=0.5]{Universit\'a};
	\node[inner sep=55pt,anchor=55,opacity=0.5]{Ca' Foscari};
	\node[inner sep=70pt,anchor=56,opacity=0.5]{Venezia};
	\end{tikzpicture}
	\begin{center}
		\vspace*{0.5cm}
		\Large
		\LARGE \textbf{Corso di Laurea }\\
		\LARGE \textbf{in Informatica}\\
		\textit{\large Ordinamento ex D.M. 270/2004}
		
		\vspace*{1cm}
		\Large Tesi di Laurea\\
		
		\vspace*{1cm}
		\LARGE \textbf{Titolo}\\
	\end{center}
	\begin{flushleft}
		\vspace*{2.6cm} \normalsize
		\textbf{Relatore}\\
		Prof. Stefano Calzavara
		
		\vspace*{1.3cm} \normalsize
		\textbf{Correlatore}\\
		Prof. Marco Squarcina
				
		\vspace*{1.3cm} \normalsize
		\textbf{Laureando}\\
		Daniele Rigon \\
		Matricola 857319 \\		
		
		\vspace*{1.3cm} \normalsize
		\textbf{Anno Accademico}\\
		2018/2019 \\	
	\end{flushleft}

\pagebreak
\cleardoublepage
\tableofcontents

\newpage
\section{Introduzione}
Negli ultimi decenni il World Wide Web è diventanto sempre più presente nella quotidianità di ogni individuo e, come la maggior parte delle cose, presenta aspetti positivi e negativi.
Essendo il web un mondo veramente vasto da scoprire, sono altrettanti i rischi presenti al suo interno.
L'obiettivo di questa tesi è spiegare come, studiando un piccolo set di API, siano state trovate delle vulnerabilità di sicurezza e privacy all'interno di queste mostrando come possano venire rubate le informazioni sensibili degli utenti ed essere usate poi da terzi.
La tesi si divide in tre parti principali, corrispondenti alle tre API prese in esame.
La prima, [che è anche la più semplice delle tre], è la Geolocation API, la quale, utilizzata nei siti web o nelle web app, serve a tracciare la posizione dell'utente, con possibili rischi di problemi di privacy; la seconda è la PaymentRequest API, la quale salva le credenziali dell'utente cosi da essere riutilizzate automaticamente senza doverle reinserirle ogni qualvolta le si usa, mostrando però che queste possono essere intercettate, e come possono essere rubate; l'ultimo argomento preso in esame, che è anche il più complesso, riguarda i Service Worker, i quali sono principalmente usati per il caching, migliorando cosi l'esperienza utente,[(e migliorano la sicurezza?)], però viene anche mostrato come questi possono essere utilizzati in modo malevolo intercettando le richieste di rete e rubando informazioni ad una potenziale vittima.
\cleardoublepage
\section{Geolocation}
\subsection{Overview}
La Geolocation API viene utilizzata per ottenere la posizione geografica di un utente. 
Poiché questo può compromettere la privacy la posizione non è disponibile a meno che l'utente non la approvi: su un dispositivo mobile avremo un set di coordinate provenienti dal sensore GPS mentre su un portatile potremo usare il posizionamento legato all’ip della connessione internet.

\subsection{Specifiche}

\subsubsection{Oggetto della geolocalizzazione}
Le API di geolocalizzazione sono pubblicate tramite l'oggetto navigator.geolocation. Se l'oggetto esiste, il servizio di geolocalizzazione è disponibile. Per testare l'esistenza di tale oggetto:
\lstinputlisting{code/GeolocationInNavigator.js}

\subsubsection{Metodi}
Ci sono solamente tre metodi a disposizione: getCurrentPosition, watchPosition e clearWatch. I primi due sono utili a ottenere la posizione corrente mentre il terzo serve ad annullare la ricerca della posizione corrente. 
La differenza tra i primi due va ricercata nella loro periodicità, mentre il primo metodo fornisce il dato una sola volta, il secondo si attiva automaticamente ogni qualvolta la posizione cambi, o ogni tot intervallo di tempo.
La sintassi per invocare questi metodi è la seguente:
\lstinputlisting{code/Sintassi.js}

\textbf{GetCurrentPosition}
\lstinputlisting{code/GetCurrentPosition.js}
L'esempio chiama la funzione dosomething() quando la posizione viene calcolata. \\
Un esempio concreto potrebbe essere il seguente\footnote{viene chiesto il permesso all'utente nell'uso della posizione quando si chiama il metodo GetCurrentPosition e WatchPosition; se negata apparirà un messaggio di errore in console, se consentita verranno mostrati i dati dell'utente}: \\
\pagebreak
\lstinputlisting{code/EsempioCompleto.js}
Che produrrà la seguente pagina:
\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{geo1}
	\caption{Pagina info Geolocation}
	\label{fig: Pagina info Geolocation}
\end{figure}
\pagebreak
\\
Quando saranno chiamati i metodi getCurrentposition o WatchPosition verrà chiesto all'utente il permesso per usare la posizione.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.4\linewidth]{geo2}
	\caption{Richiesta permesso}
	\label{fig: Richiesta permesso}
\end{figure}
\\
Se l'utente rifiuta la posizione non viene calcolata e viene mostrato un messaggio di errore in console.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.4\linewidth]{geo3}
	\caption{Rifiuto autorizzazione}
	\label{fig: Rifiuto autorizzazione}
\end{figure}
\pagebreak
\\
Se l'utente acconsente all'utilizzo della posizione verrà mostrato un messaggio di conferma in console e saranno mostrate a video tutte le informazioni disponibili dell'utente.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.4\linewidth]{geo4}
	\caption{Accetto autorizzazione}
	\label{fig: Accetto autorizzazione}
\end{figure}
\\
\textbf{WatchPosition}
\\
Se la posizione cambia (perché il dispositivo si sposta o perché viene calcolata una posizione più accurata), si può settare una funzione che viene chiamata quando la posizione attuale si aggiorna. Basta usare la funzione watchPosition(), che ha gli stessi parametri di input di getCurrentPosition(). Questa funzione viene chiamata più volte così da permettere al browser di sapere sempre la posizione del dispositivo. La funzione di errore è opzionale come lo era per getCurrentPosition().
\lstinputlisting{code/WatchPosition.js}
Il metodo watchPosition() ritorna un ID numerico che può essere usato per identificare univocamente il controllo della posizione. 
\\
\textbf{ClearPosition}
\\
Viene usato il metodo clearWatch() per annullare il monitoraggio della posizione.
\lstinputlisting{code/ClearPosition.js}

\subsection{Problemi sicurezza/privacy}
Uno dei principali problemi con la Geolocation API è rappresentato dagli attacchi di cross-site scripting (XSS) dovuto al fatto che gli oggetti per tracciare le coordinate (latitudine e longitudine) risiedono all'interno del DOM, il quale è accessibile con JavaScript e attraverso il quale potrebbe essere rubata la posizione dell'utente. 
Dato che gli utenti si fidano del sito web, si fidano anche della richiesta di posizione e la condividono.
Un problem importante è che se l'utente non disabilita il tracciamento il browser continuerà a esporre la posizione dell'utente all'attaccante.
\begin{figure}[h]
	\centering
	\includegraphics[width=1\linewidth]{pos1}
	\caption{Richiesta posizione}
	\label{fig: Richiesta posizione}
\end{figure}
\\
Supponiamo che un utente malintenzionato abbia rilevato una vulnerabilità XSS in un sito Web; tutto ciò che dovra fare è fare in modo che la vittima esegua il seguente codice JavaScript per rubare la posizione.

\lstinputlisting{code/script.js}
Il codice utilizza le proprietà del DOM cords.latitude e cords.langitude per determinare rispettivamente la latitudine / longitudine e le memorizza in una variabile. Successivamente il codice JavaScript invia i dati al dominio dell'attaccante, in modo diverso a seconda di come è stato configurata la richiesta.
\\
\clearpage
Se l'utente non consente all'utilizzo della posizione non succederà nulla nella pagina.
\begin{figure}[h]
	\centering
	\includegraphics[width=1\linewidth]{Blocca}
	\caption{Blocca autorizzazione}
	\label{fig: Blocca autorizzazione}
\end{figure}
\\
Se l'utente acconsente all'utilizzo della posizione essa sarà calcolata e, risiedendo nel DOM, può esser facilmente rubata.
\begin{figure}[h]
	\centering
	\includegraphics[width=1\linewidth]{Consenti}
	\caption{Consenti autorizzazione}
	\label{fig: Consenti autorizzazione}
\end{figure}
\clearpage
\subsection{Supporto compatibilità web}
\subsubsection{Desktop e mobile}
\begin{figure}[h]
	\centering
	\includegraphics[width=1\linewidth]{compatibility}
	\caption{Desktop and mobile compatibility}
	\label{fig: Desktop and mobile compatibility}
\end{figure}
\subsection{Conclusioni}
La Geolocation API è una delle API più semplici.

\cleardoublepage
\newpage
\section{PaymentRequest API}

\subsection{Overview Payment Request}
La PaymentRequest API nasce con l'intento di creare esperienze di pagamento semplificate, in quanto ogni sito web ha il proprio sistema di pagamento e molti siti richiedono la ridigitazione manuale delle stesse informazioni più volte, le quali possono essere invece memorizzate e riutilizzate dall'API per completare più rapidamente le transazioni online.

\subsubsection{Vantaggi}
\begin{itemize}
	\item \textbf{Esperienza di acquisto rapida:} gli utenti immettono i propri dati una sola volta nel browser, e dopo averli inseriti non è più necessario reinserirli su siti diversi;
	\item \textbf{Esperienza coerente su ogni sito che supporta l'API:} poiché la pagina di pagamento è controllata dal browser si può personalizzare l'esperienza utente, ad esempio includendo la localizzazione per impostare automaticamente la lingua preferita dell'utente o altre features;
	\item \textbf{Gestione delle credenziali:} gli utenti possono gestire le loro carte di credito e gli indirizzi di spedizione direttamente nel browser. Un browser può anche sincronizzare queste "credenziali" tra dispositivi, rendendo più semplice per gli utenti passare dal desktop al cellulare e viceversa quando si acquistano oggetti;
	\item \textbf{Gestione coerente degli errori:} il browser può controllare la validità dei numeri delle carte e può comunicare all'utente se una carta è scaduta o sta per scadere, può suggerire automaticamente quale carta utilizzare in base ai modelli di utilizzo passati o alle restrizioni del commerciante, o consentire all'utente di dire quale sia la carta predefinita/preferita;
	\item \textbf{Esperienza utente migliorata:} meno tipizzazione, coerenza tra i siti Web, tra browser e sistemi operativi e nuove funzionalità del browser per semplificare il checkout, ecc;
	\item \textbf{Miglioramento della sicurezza:} la PaymentRequest API ha il potenziale per ridurre le opportunità di frode e può facilitare l'adozione di metodi di pagamento più sicuri. Purtroppo ci sono dei problemi di sicurezza analizzati al capitolo 4; 
	\item \textbf{Responsabilità inferiore:} in passato, per creare un'esperienza utente semplificata, i commercianti dovevano memorizzare le credenziali di pagamento degli utenti. Questo non è più necessario, il che può aiutare a ridurre la responsabilità del commerciante nei confronti del cliente.
\end{itemize}

\subsubsection{Come funziona}	
La PaymentRequest API consente a un utente di completare una transazione più facilmente riutilizzando le informazioni memorizzate nel browser o in app di pagamento di terze parti.
Quando l'utente preme un pulsante in una pagina di checkout collegata all'API il commerciante utilizza l'API per richiedere il pagamento. Il commerciante fornisce informazioni su prezzo, valuta e un elenco di metodi di pagamento accettati, e può inoltre richiedere al browser di creare un'interfaccia utente semplificata per raccogliere l'indirizzo di spedizione, le informazioni di contatto e altri elementi all'utente.
Il browser determina quali metodi di pagamento sono supportati dal commerciante tra le varie "app di pagamento" mostrandole all'utente. 
L'utente seleziona un'app di pagamento con la quale pagare, la quale può comportare ulteriori interazioni con l'utente (ad esempio per l'autenticazione). 
Al completamento l'app di pagamento restituisce i dati tramite l'API al commerciante.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\linewidth]{SchemaPayment}
	\caption{Schema Payment Request API}
	\label{fig:Schema Payment}
\end{figure}
\pagebreak

\subsubsection{Uso API}
\textbf{Ruolo dell'utente}
\\
Gli utenti beneficiano del riutilizzo delle informazioni inserite nel browser o nelle app di pagamento. Quindi, quando si visita un sito Web che sfrutta la PaymentRequest API gli utenti avranno l'opportunità di sfruttare il riutilizzo semplificato delle informazioni archiviate.
\\
\textbf{Ruolo del commerciante}
\\
L'API influisce sul front end (l'interfaccia dell'esperienza utente) e non sul back-end, pertanto il commerciante non dovrebbe dover apportare modifiche all'elaborazione back-end dei vari metodi di pagamento; questo sarà compito del fornitore della pagina di pagamento il quale sostituirà i moduli Web con le chiamate alla PaymentRequest API.
\\
\textbf{Ruolo del browser}
\\
Il browser svolge diversi ruoli:
\begin{itemize}
	\item Calcola l'intersezione dei metodi di pagamento accettati dal commerciante e registrati dall'utente;
	\item Visualizza l'interfaccia utente che consente all'utente di inserire le proprie informazioni;
	\item Funge da canale per i dati da e verso il commerciante e da e verso l'utente.
\end{itemize}
\textbf{Metodi di pagamento}
\\
La PaymentRequest API è progettata per funzionare con un gran numero di metodi di pagamento, i quali vengono identificati attraverso due strade:
\begin{itemize}
	\item I metodi di pagamento definiti da W3C sono identificati come "basic-card" e sono composti da stringhe corte;
	\item I metodi di pagamento definiti da altre parti sono identificati dagli URL.
\end{itemize}
\textbf{App di pagamento}
\\
La PaymentRequest API determina se un'app di pagamento "corrisponde" a una determinata transazione definendo un algoritmo che considera i metodi di pagamento accettati dal commerciante, dichiarati attraverso un elenco di identificativi del metodo di pagamento, passati attraverso l'API.
Al fine di proteggere la privacy degli utenti i commercianti hanno accesso a informazioni molto limitate dell'utente. 

Vediamo in che modo la PaymentRequest API influisce sul flusso dei metodi di pagamento che già supporta. Il normale flusso per gli utenti di solito implica qualcosa del genere:
\begin{itemize}
	\item Scansione di un elenco di metodi di pagamento accettati;
	\item Scelta di un metodo;
	\item Per i metodi di pagamento che prevedono il lancio di un'app o la visita a un sito Web si invia l'utente a quell'app o sito;
	\item Pagamento completato.
\end{itemize}
La PaymentRequest API consente un flusso migliorato:
\begin{itemize}
	\item L'utente preme un pulsante di acquisto singolo;
	\item Il browser visualizza le app di pagamento dell'utente che possono essere utilizzate per la transazione, ed è probabile che i browser supportino le preferenze dell'utente in modo che un'app di pagamento venga avviata automaticamente su un determinato sito Web, semplificando il checkout.
	\item Per i metodi di pagamento che prevedono il lancio di un'app o la visita a un sito Web, inviare l'utente a quell'app o sito; 
	\item Pagamento completato; 
\end{itemize}
\textbf{Differenze tra metodo di pagamento e app di pagamento}
\\
Un'app di pagamento è il software che l'utente utilizza per pagare, la quale può supportare uno o più metodi di pagamento e può essere implementata utilizzando diverse tecnologie. I browser possono anche fungere da app di pagamento, memorizzando le credenziali dell'utente. In generale più app di pagamento possono implementare lo stesso metodo di pagamento. 
Vi sono casi importanti in cui è disponibile una sola app di pagamento autorizzata a supportare un metodo di pagamento, mentre ci sono casi in cui più app di pagamento possono servire diversi metodi di pagamento. In questo caso non è il commerciante che deve preoccuparsi dell'integrazione software, ma deve solamente richiedere le informazioni attraverso la PaymentRequest API.

\subsection{Specifiche}
\subsubsection{Metodi}
Per utilizzare l'API lo sviluppatore deve fornire e tenere traccia di una serie di informazioni chiave, le quali vengono passate al costruttore PaymentRequest come argomenti e successivamente utilizzate per aggiornare la richiesta di pagamento visualizzata all'utente. Queste informazioni sono:
\begin{itemize}
	\item \textbf{PaymentMethodData:} rappresenta i metodi di pagamento che il sito supporta;
	\item \textbf{PaymentDetails:} rappresenta i dettagli della transazione. Ciò include il costo totale e facoltativamente un elenco di beni o servizi acquistati, beni materiali, opzioni di spedizione o "modificatori" su come vengono effettuati i pagamenti: ad esempio "se paghi con una carta di credito di tipo X incorre in una tassa di elaborazione di tot";
	\item \textbf{PaymentOptions:} il PaymentOptions viene passato al costruttore PaymentRequest e fornisce informazioni sulla consegna del prodotto: ad esempio per i beni fisici il commerciante avrà bisogno di un indirizzo fisico dove spedire, mentre per i beni digitali e sufficeinte un'e-mail. Una volta che il PaymentRequest è stato costruito viene presentato all'utente finale tramite il metodo show(), il quale ritorna una promise che, una volta che l'utente conferma la richiesta di pagamento, si traduce in una PaymentResponse;
	\item \textbf{PaymentRequest:} la PaymentRequest serve a effettuare una richiesta di pagamento, in genere associata all'avvio di un processo di pagamento da parte dell'utente. La PaymentRequest consente agli sviluppatori di scambiare informazioni con l'user agent mentre l'utente sta fornendo dati in input. Poiché la visualizzazione simultanea di più interfacce PaymentRequest potrebbe confondere l'utente, questa specifica limita lo user agent a visualizzarne uno alla volta tramite il metodo show();
	\item \textbf{PaymentDetailsInit:} Il PaymentDetailsInit viene utilizzato nella costruzione della richiesta di pagamento;
	\item \textbf{PaymentResponse:} un PaymentResponse viene restituito quando un utente ha selezionato un metodo di pagamento e approvato una richiesta di pagamento.
\end{itemize}

\pagebreak
\textbf{PaymentMethodData}
\\
PaymentMethodData contiene gli identificativi dei metodi di pagamento accettati dal sito Web e qualsiasi dato specifico del metodo di pagamento associato.
\lstinputlisting{code/PaymentMethodData.js}
\textbf{PaymentDetails}
\\
I details contengono informazioni sulla transazione che l'utente è invitato a completare.
\lstinputlisting{code/PaymentDetails.js}
\pagebreak
\textbf{Opzioni di spedizione}
\\
Qui vediamo un esempio di come aggiungere due opzioni di spedizione ai details.
\lstinputlisting{code/OpzioniSpedizione.js}

\flushleft\textbf{Modifiche condizionali alla richiesta di pagamento}
\\
Qui vediamo come aggiungere una tassa di elaborazione per l'utilizzo di una carta di credito. Si noti che richiede il ricalcolo del totale.
\lstinputlisting{code/Tassa.js}
\pagebreak
\textbf{PaymentOptions} \\
Options contiene informazioni che lo sviluppatore ha bisogno dall'utente per eseguire il pagamento.
\lstinputlisting{code/PaymentOptions.js}

\textbf{PaymentRequest} \\
Dopo aver raccolto tutti i bit di informazioni prerequisite, ora possiamo costruirne uno PaymentRequest e richiedere che il browser lo presenti all'utente.
\lstinputlisting{code/PaymentRequest.js}

\subsection{Rischi e sicurezza}
La PaymentRequest API aumenta la sicurezza poichè:
\begin{itemize}
	\item I commercianti possono ottenere un checkout semplificato senza memorizzare le informazioni dell'utente, in quanto lo fa l'API;
	\item La PaymentRequest API dovrebbe facilitare l'introduzione di metodi di pagamento più sicuri sul Web, come i pagamenti con carta tokenizzata;
	\item I proprietari dei metodi di pagamento disporranno di meccanismi standard per autorizzare software specifici a implementare il loro metodo di pagamento, che il browser può verificare attraverso una firma digitale.
\end{itemize}

\subsubsection{Esempio di un possibile attacco}
\textbf{Descrizione dell'attacco}
\\
L'API apre una finestra dove inserire le informazioni, le quali però possono essere intercettate come verrà mostrato nell'esempio di seguito. 
L'API salva le informazioni dell'utente ma viene chiesto ogni volta di inserire il codice CVV come forma di sicurezza, quindi per l'attaccante sarà possibile in ogni sessione rubare le informazioni inserite dall'utente.
Alla richiesta di avvio di un processo di pagamento viene creato l'oggetto PaymentRequest nel quale vengono inseriti tutti i dati che l'utente inserisce. Una volta che l'utente ha approvato una richiesta di pagamento viene restituito un PaymentResponse per approvare tale richiesta. L'oggetto PaymentRequest, creato in precedenza e contenente i dati dell'utente, passa però attraverso il DOM, e quindi può essere intercettato. Ad esempio nel campo details.cardNumber si può leggere il numero di carta di credito, mentre in details.cardSecurityCode si può leggere il codice CVV; entrambi sono mostrati nell'esempio in Figura 4.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{Chrome1}
	\caption{Inserimento informazioni dell'utente}
	\label{fig: Inserimento informazioni dell'utente}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{Chrome2}
	\caption{Inserimento CVV}
	\label{fig: Inserimento CVV}
\end{figure}
\pagebreak
\\
Dopo l'elaborazione i numeri di carta di credito e CVV saranno visibili all'attaccante.
\\
\begin{figure}[h]
	\centering
	\includegraphics[width=1\linewidth]{Informazioni}
	\caption{Informazioni rubate}
	\label{fig: Informazioni rubate}
\end{figure}
\textbf{Come difendersi}
\\
-- E COSI E NON SI PUO FAR NIENTE? --
\pagebreak
\subsection{Implementazione PaymentRequest API su una pagina d'esempio}
\subsubsection{Costruttore}
L'oggetto PaymentRequest è costruito passando i seguenti parametri:
\begin{itemize}
	\item \textbf{methodData:} una serie di identificativi del metodo di pagamento e tutti i dati pertinenti. Un identificativo del metodo di pagamento è una stringa che identifica un metodo di pagamento supportato;
	\item \textbf{details:} contiene le informazioni sulla transazione, come gli elementi pubblicitari in un ordine;
	\item \textbf{options:} contiene informazioni aggiuntive che il Wallet potrebbe dover raccogliere.
\end{itemize}

Nel seguente esempio stiamo consentendo agli utenti di pagare con qualsiasi carta di debito o di credito appartenente alle reti Visa, MasterCard o Amex. L'oggetto details contiene l'importo totale parziale, l'imposta sulle vendite e il totale dovuto; questi dettagli verranno mostrati all'utente nel portafoglio. Bisogna tenere presente che l'API non aggiunge elementi o calcola l'imposta sulle vendite, spetta al commerciante fornire le informazioni corrette. In questo esempio, stiamo vendendo un bene fisico, quindi chiediamo l'indirizzo di spedizione del cliente.
\lstinputlisting{code/Costruttore.js}
\subsubsection{Visualizzazione dell'interfaccia utente, elaborazione del pagamento e visualizzazione dei risultati}
Una volta creato l'oggetto PaymentRequest è possibile attivare il browser per visualizzare il wallet con request.show(). 
\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{wallet1}
	\caption{Wallet dopo la chiamata request.show()}
	\label{fig: Wallet dopo la chiamata request.show()}
\end{figure}
I clienti possono  selezionare le informazioni di pagamento, l'indirizzo di spedizione e altri campi appropriati e cliccare su Paga quando è pronto. A questo punto, gli utenti dovranno verificare la loro identità: in caso di esito positivo verrà soddisfatta la promise request.show() e verranno restituite al sito Web tutte le informazioni che il cliente ha fornito. Per il metodo di pagamento con carta di base l'oggetto risultante conterrà il nome del titolare della carta, il numero della carta, il mese di scadenza e altri campi pertinenti. Il commerciante può quindi utilizzare queste informazioni per elaborare la transazione sul back-end.
Dopo che la risposta è tornata dal server, è possibile utilizzare result.complete('success') per visualizzare la schermata di successo o result.complete('fail') per indicare una transazione fallita.
\lstinputlisting{code/PaymentShow.js}
\pagebreak
Ed ecco i wallet in caso di successo e di fallimento.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{wallet2}
	\caption{Wallet in caso di successo}
	\label{fig: Wallet in caso di successo}
\end{figure}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{wallet3}
	\caption{Wallet in caso di fail}
	\label{fig: Wallet in caso di fail}
\end{figure}
\clearpage
\subsubsection{Ascoltare gli eventi}
Il prezzo potrebbe cambiare in base all'indirizzo di spedizione e alle opzioni di spedizione selezionate dal cliente. È possibile ascoltare tali modifiche con gli eventi shippingaddresschange e shippingoptionchange per ricalcolare di conseguenza i prezzi.
\lstinputlisting{code/Events.js}

\subsection{Compatibilità web}
\subsubsection{Desktop}
\begin{figure}[h]
	\centering
	\includegraphics[width=1\linewidth]{Compatibilita1}
	\caption{Compatibilità desktop}
	\label{fig: Compatibilità desktop}
\end{figure}
\subsubsection{Mobile}
\begin{figure}[h]
	\centering
	\includegraphics[width=1\linewidth]{Compatibilita2}
	\caption{Compatibilità mobile}
	\label{fig: Compatibilità mobile}
\end{figure}
\subsection{Conclusioni}
La PaymentRequest API è uno strumento per migliorare l'esperienza utente sul Web offrendo ai clienti un'esperienza di acquisto più piacevole, pur avendo delle vulnerabilità. (possono essere colmate?)
\newpage
\cleardoublepage
\section{Service Worker}
\subsection{Overview}
Un ServiceWorker è uno script Javascript che utilizza le Promises per poter eseguire operazioni in modalità asincrona nel browser, avviate in background separato dalla pagina; pertanto non possono modificarne gli elementi del DOM come i normali script ma può comunicare con essi mediante “messaggi”.
Un ServiceWorker si trova tra la nostra applicazione Web e la rete e, come un server proxy, può intercettare tutte le richieste a pagine web e file statici e rispondere secondo politiche che siamo noi stessi a decidere.
I ServiceWorker sono pensati per consentire la creazione di esperienze offline efficaci, intercettare le richieste di rete e intraprendere azioni appropriate in base al fatto che la rete sia disponibile o meno e aggiornare le risorse che risiedono sul server, oltre a consentire l'accesso alle notifiche push e alle API di sincronizzazione in background.
È il browser che in qualsiasi momento deciderà se il ServiceWorker dovrebbe essere o meno in esecuzione così da risparmiare risorse, specialmente sui dispositivi mobili. Per questo può essere che se non facciamo alcuna richiesta HTTP per un certo periodo di tempo o non riceviamo alcuna notifica per un po' è possibile che il browser spenga il Service Worker. Se attiviamo una richiesta HTTP che deve essere gestita dal ServiceWorker il browser la attiverà di nuovo, nel caso in cui non fosse ancora in esecuzione. 

\subsubsection{Impostare i service worker}
Molte funzionalità dei Service Worker oggi sono abilitate di default, ma nel caso non lo fossero bisogna abilitarle nel browser:
\begin{itemize}
	\item Firefox: su \url{about:config} impostare dom.serviceWorkers.enabled su true, riavvia il browser;
	\item Chrome : su \url{chrome://flags} accendere  experimental-web-platform-features, riavvia browser;
	\item Opera : su \url{opera://flags} attivare Support for ServiceWorker, riavvia il browser;
	\item Microsoft Edge : su \url{about:flags} spuntare  Enable service workers, riavvia il browser.
\end{itemize}

\subsubsection{Architettura di base}
Per quanto riguarda i ServiceWorker generalmente vengono eseguiti questi passaggi per l'impostazione di base:
\begin{itemize}
	\item L'URL del ServiceWorker viene recuperato e registrato tramite serviceWorkerContainer.register();
	\item In caso di esito positivo il ServiceWorker viene eseguito in un ServiceWorkerGlobalScope, ovvero un tipo speciale di ServiceContext che scappa dal thread di esecuzione dello script principale senza accesso DOM. Il ServiceWorker ora è pronto per elaborare gli eventi;
	\item L'installazione del ServiceWorker viene tentata quando si accede successivamente alle pagine: un evento di installazione è sempre il primo inviato a un ServiceWorker;
	\item Quando il ServiceWorker è considerato installato il passo successivo è l'attivazione, quindi quando il ServiceWorker è installato riceve un evento di attivazione.
\end{itemize}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.6\linewidth]{SwLifecycle}
	\caption{Ciclo di vita del Service Worker}
	\label{fig:Ciclo di vita del Service Worker}
\end{figure}

\subsubsection{Casi d'uso}
I Service Worker sono destinati anche ad altri usi:
\begin{itemize}
	\item Sincronizzazione dei dati in background;
	\item Risposta a richieste di risorse da altre origini;
	\item Ricezione di aggiornamenti centralizzati a dati costosi da calcolare in modo che più pagine possano utilizzare un set di dati;
	\item Modelli personalizzati basati su determinati pattern URL;
	\item Miglioramenti delle prestazioni, ad esempio prelettura delle risorse che l'utente probabilmente avrà bisogno nel prossimo futuro.
\end{itemize}
Altre specifiche sono utilizzate dal Service Context, ad esempio:
\begin{itemize}
	\item Sincronizzazione in background : avvia un operatore di servizio anche quando nessun utente si trova sul sito, quindi le cache possono essere aggiornate, ecc;
	\item Reagire per inviare messaggi : si può avviare un Service Worker per inviare agli utenti un messaggio per comunicare loro che sono disponibili nuovi contenuti;
	\item Reagendo ad orari e date particolari.
\end{itemize}

\subsection{Ciclo di vita di un Service Worker}
Il ciclo di vita di un service worker è composto da quattro fasi:
\begin{itemize}
	\item Registrazione: il service worker viene scaricato dal browser, analizzato ed eseguito;
	\item Installazione: il service worker viene installato;
	\item Attivazione: il service worker è pronto ed è in grado di poter controllare gli eventi generati dal client;
	\item Fetch: evento generato dal client. Il service worker è in grado di intercettare le richieste e rispondere secondo le opportune strategie di caching. 
\end{itemize}

\subsubsection{Registrazione}

Come prima cosa bisogna comunicare al browser l’esistenza di un ServiceWorker all’interno del sito web. Un ServiceWorker viene prima registrato utilizzando il metodo ServiceWorker.register() e per farlo basta inserire su tutte le pagine del sito uno script come il seguente:
\lstinputlisting{code/Registrazione.js}
Il codice inizia controllando il supporto da parte del browser verificando la presenza di navigator.serviceWorker. Se supportato, il ServiceWorker viene registrato per mezzo di navigator.serviceWorker.register che restituisce un oggetto Promise il quale si risolve con successo a registrazione avvenuta correttamente.
service-worker.js è il file Javascript residente nella root del sito web e che contiene il codice del service worker, il cui codice è:
\pagebreak
\lstinputlisting{code/Registrazione2.js}
In questo modo viene registrato un ServiceWorker il quale viene semplicemente installato e ad ogni richiesta stampa in console un messaggio con la URL che il browser tenta di scaricare dal server web. Per controllare il caricamento di un Service Worker il codice di questo deve essere eseguito al di fuori delle normali pagine.

Possono esserci diversi motivi per cui il Service Worker non si registra:
\begin{itemize}
	\item Non si sta eseguendo l'applicazione tramite HTTPS;
	\item Il path del Service Worker non è scritto correttamente: deve essere scritto in relazione all'origine, non alla directory radice dell'app;
	\item Il Service Worker a cui ci si riferisce ha un'origine diversa da quella della tua app.
\end{itemize}

\subsubsection{Installazione}
Il ServiceWorker viene scaricato immediatamente quando un utente accede per la prima volta a un sito, o una pagina, controllata dal ServiceWorker, e sarà poi scaricato periodicamente ogni tot periodo di tempo.

L'installazione viene tentata quando il file nuovo che è stato scaricato risulta diverso da un ServiceWorker esistente, o risulta essere diverso dal primo ServiceWorker rilevato per quella pagina/sito. Se è la prima volta che un ServiceWorker viene reso disponibile viene tentata l'installazione e, dopo un'installazione corretta, viene attivato. Se è disponibile un ServiceWorker esistente la nuova versione viene installata in background, ma non ancora attivata; si attiva solo quando non ci sono più pagine caricate che stanno ancora utilizzando il vecchio ServiceWorker. Non appena non ci sono più pagine da caricare il nuovo ServiceWorker si attiva.

Conseguentemente all’installazione viene richiamato l’evento install: tale evento consente di effettuare il precaching, ovvero inserire in cache pagine e file statici del sito web prima di intercettarne le richieste. Per farlo occorre utilizzare gli oggetti Promise event e cache come segue:
\pagebreak
\lstinputlisting{code/Installazione.js}
Se si decidesse di aggiungere/eliminare nuove risorse da inserire in cache bisognerà avere l’accortezza di cambiare il nome della versione del ServiceWorker ed eliminare dalla cache le risorse già presenti.
Una cosa molto importante da sapere è che le risorse da inserire in cache in fase di precaching devono esistere realmente sul server web altrimenti il ServiceWorker genererà un errore fatale e l’installazione non andrà a buon fine. 
Il metodo skipWaiting() consente al ServiceWorker di passare allo stato di attivazione ad installazione conclusa e quindi essere subito operativo.

\subsubsection{Attivazione}
Una volta installato il ServiceWorker passa nello stato di attivazione. Se la pagina al momento è controllata da un altro ServiceWorker quello attuale passa in uno stato di attesa per poi diventare operativo al prossimo caricamento di pagina quando il vecchio ServiceWorker viene sostituito.
Questo per essere sicuri che solo un ServiceWorker (o una sola versione di ServiceWorker) per volta possa essere eseguito nello stesso contesto.
A ServiceWorker attivato viene richiamato l’evento activate, ovvero l'evento per svuotare la cache obsoleta dell’eventuale precedente versione di ServiceWorker. Dopodiché il ServiceWorker sarà in grado di effettuare il fetching di risorse o di restare in attesa di altri eventi.
Di default il nuovo ServiceWorker diventa operativo al refresh della pagina o dopo aver richiamato il metodo clients.claim(); fino a quel momento le eventuali richieste non saranno intercettate. 

\subsubsection{Fetch}
Grazie all’evento fetch il ServiceWorker potrà agire da proxy tra l’applicazione web e la rete.
Il ServiceWorker intercetterà ogni richiesta HTTP del browser e sarà in grado di rispondere a quest’ultimo prendendo la risorsa dalla cache piuttosto che scaricarla dalla rete.
Grazie all’evento fetch il ServiceWorker diventa un vero e proprio strumento per migliorare le performance di caricamento di un sito web.

\subsubsection{Aggiornare il Service Worker}
Se il ServiceWorker è già stato installato ma una nuova versione è disponibile per l'aggiornamento o il caricamento della pagina, la nuova versione viene installata in background ma non sarà ancora attivata. Si attiva solo quando non ci sono più pagine caricate che stanno ancora utilizzando il vecchio servizio. Non appena non ci sono più pagine di questo tipo ancora caricate, il nuovo ServiceWorker si attiverà.

Si dovrà aggiornare il listener install di eventi nel nuovo Service Worker, similmente a questo:
\lstinputlisting{code/Aggiornamento.js}
Mentre accade questo è ancora la versione precedente (v1) quella responsabile per i recuperi, mentre la nuova versione (v2) si sta installando in background.
Quando nessuna pagina sta utilizzando la versione corrente, il nuovo operatore si attiva e diventa responsabile dei recuperi.

\subsubsection{Disintallare il Service Worker}

Rimuovere/disinstallare un ServiceWorker è un’operazione semplice. È possibile eseguirla manualmente dal proprio browser oppure inserendo un semplice script al posto di quello di registrazione del service worker:
\lstinputlisting{code/Disinstallare.js}
Naturalmente è necessario che la pagina contenente il codice di disinstallazione venga visitata dal browser, oppure è possibile rimuovere il ServiceWorker manualmente tramite DevTools.
\newpage
\subsection{Strategie di caching (le lascio o non servono?)}
Diverse sono le strategie che possono essere adottate per migliorare le performance di un sito web mediante i service worker. A seconda del sito e del contesto è possibile adottare una strategia piuttosto che l’altra.
È importante sottolineare che il ServiceWorker non utilizza cache a meno che non siamo noi a dirlo, quindi di default il comportamento nella fase di fetch delle risorse sarà quello nativo del browser.
Di seguito l’elenco completo delle strategie con esempi di codice di implementazione. 
\subsubsection{Network first}
Questa strategia mira ad avere un contenuto sempre fresco scaricandolo dalla rete, fornendo la copia in cache solo in caso di problemi di connettività (ad esempio in caso di connessione offline).
\lstinputlisting{code/Networkfirst1.js}
Una modifica interessante in questo caso potrebbe essere quella di aggiornare la copia in cache quando la risorsa viene scaricata dalla rete, cosicché in caso di errori di connessione viene restituita la copia più giovane.
\lstinputlisting{code/Networkfirst2.js}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{Strategia1}
	\caption{Network first}
	\label{fig: Network first}
\end{figure}
\subsubsection{Cache first}
Chiamata anche cache, falling back to network, questa strategia verifica se la risorsa è disponibile in cache. Se così fosse viene restituita la copia in cache. In caso contrario la risorsa viene scaricata dalla rete.
\lstinputlisting{code/CacheFirst.js}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{Strategia2}
	\caption{Cache First}
	\label{fig: Cache First}
\end{figure}
\subsubsection{Network only}
È la strategia più banale in quanto viene simulato il normale comportamento del browser, ovvero scaricare le risorse direttamente dalla rete.

Per applicare  questa strategia basta non inserire alcuna riga di codice all’interno dell’evento fetch:
\lstinputlisting{code/NetworkOnly1.js}
o al limite inserire semplicemente la seguente riga:
\lstinputlisting{code/NetworkOnly2.js}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{Strategia3}
	\caption{Network only}
	\label{fig: Network only}
\end{figure}
\pagebreak
\subsubsection{Cache only}
Esattamente opposta alla strategia network only, in questo caso il service worker risponde solo con elementi conservati in cache. In caso di miss la risposta restituita al browser simulerà l’errore di connessione.
\lstinputlisting{code/CacheOnly.js}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{Strategia4}
	\caption{Cache Only}
	\label{fig: Cache Only}
\end{figure}
\subsubsection{Fastest}
Questa strategia mira a fornire all’utente la risposta più veloce. Il ServiceWorker avvia contemporaneamente una richiesta in cache ed una in rete. La prima che risponde verrà restituita all’utente.
Questa soluzione può essere l’ideale per quei dispositivi con vecchi hard drive dove la lettura da disco può addirittura rivelarsi più lenta del fetch dalla rete. Per i dispositivi moderni è meglio utilizzare la strategia cache then network.
Siccome il ServiceWorker può ritornare un solo Promise, occorre realizzare una funzione a cui passare un array di oggetti Promise, in questo caso cache e fetch, e risolverli quasi contemporaneamente ritornando quello che si risolve per primo.
\pagebreak
\lstinputlisting{code/Fastest.js}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{Strategia5}
	\caption{Fastest}
	\label{fig: Fastest}
\end{figure}
\subsubsection{Cache then network}
Questa strategia mira a fornire il contenuto dalla cache per una risposta molto rapida. Dopodiché in parallelo si avvia una richiesta in rete per scaricare una copia aggiornata della risorsa e sostituirla con quella in cache. La risorsa ricevuta dalla rete viene poi sostituita con quella presente sulla pagina.
Per ottenere questo obiettivo occorre avere sia codice lato pagina che lato ServiceWorker. Questo perché il ServiceWorker deve rispondere subito e non può attendere il completamento di un secondo task senza rallentare l’intera operazione.
Per ottenere qualcosa di analogo usando il solo ServiceWorker occorre utilizzare postMessage affinché la pagina comunichi al service worker la risorsa da interpellare con un secondo fetch, sia esso dalla cache o dalla rete. La complessità rimane uguale ma molto utile in caso si utilizzi il service worker per fare page caching.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{Strategia6}
	\caption{Cache then Network}
	\label{fig: Cache then Network}
\end{figure}
\newpage
\subsection{Rischi e sicurezza}
Come già detto i Service Worker operano solo in contesti protetti, ma questo non vuol dire che l'ambiente sia sicuro al 100\% in quanto un ServiceWorker ha la possibilità di importare script da qualsiasi altra origine tramite la chiamata a importScripts, aumentando la capacità di un attaccante XSS di inserire il proprio codice javascript all'interno della pagina, potendo cosi rubare informazioni dell'utente, ad esempio all'inserimento di username e password in una data pagina e portarle fuori. La registrazione dei Service Worker specifica che essi devono essere eseguiti nella stessa origine dei loro chiamanti; il confronto dell'origine è una corrispondenza col prefisso più lungo degli URL serializzati compreso il percorso, quindi ad esempio https://example.com è differente da https://example.com.evil.com. Quindi un attaccante può effettivamente registrare un Service Worker malevolo. Per mitigare questo rischio il browser richiede che l'URL di registrazione del Service Worker provenga dall'origine stessa; quindi per registrare un Service Worker malevolo attraverso un attacco XSS l'utente malintenzionato ha bisogno di ospitare i propri script sul server.
\\
Un possibile scenario potrebbe essere questo: se la pagina ha una vulnerabilità XSS ha anche un endpoint JSONP \footnote{Utilizzato per richiedere dati da un server che risiede in un dominio diverso da quello del client; consente la condivisione dei dati aggirando la politica della stessa origine} e l'utente malintenzionato potrebbe utilizzarlo per:
\begin{itemize}
	\item bypassare CSP\footnote{Cryptographic Service Provider, libreria software sviluppata da Microsoft};
	\item registrare un Service Worker; 
	\item chiamare importScripts per importare uno script malevolo da terze parti.
\end{itemize}
In una situazione XSS del genere il limite della direttiva cache di 24 ore garantisce che un Service Worker malevolo o compromesso sopravviverà a un massimo di 24 ore, o meno in base a come è impostato il sito. Una possibile mitigazione del problema potrebbe essere accorciare la vita dei Service Worker, ovviamente in modo ragionevole altrimenti non sarebbero sfruttate le potenzialità.
\\
Inoltre un Service Worker potrebbe non essere usato solamente per il caching, migliorando i tempi di risposta dell'applicazione o del sito, ma potrebbe anche essere usato per intercettare messaggi, modificandoli e restituendoli errati (similmente a man-in-the-middle).


- Pro: - VEDERE SE I SW POSSONO MIGLIORARE LA SICUREZZA DI UNA PAGINA, SENZA ESSERE USATI SOLO PER FARE CACHING -
\newpage
\subsection{Esempio di attacco}
Supponiamo di avere questa pagina HTML che carica uno script per l'installazione di un Service Worker, pensando sia sicuro.
\lstinputlisting{code/index.html}
Il file script.js sarà il seguente:
\lstinputlisting{code/scriptSW.js}

Mentre hack.js, che intercetta ogni richiesta, sarà questo:
\pagebreak
\lstinputlisting{code/hack.js}
Infine il file che installerà il Service Worker malevolo sarà questo:
\lstinputlisting{code/install.js}
Ogni richiesta che verrà fatta sarà intercettata dal Service Worker (in questo caso uscirà il messaggio "Intercepted" nella pagina web) fino a che non sarà disinstallato e non verrà cancellata la cache.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{Intercepted}
	\caption{Intercepted}
	\label{fig: Intercepted}
\end{figure}

\newpage
\subsection{Compatibilità web}
\subsubsection{Desktop}
\begin{figure}[h]
	\centering
	\includegraphics[width=1\linewidth]{CompWeb}
	\caption{Compatibilità web}
	\label{fig:Compatibilità web}
\end{figure}
\subsubsection{Mobile}
\begin{figure}[h]
	\centering
	\includegraphics[width=1\linewidth]{CompMobile}
	\caption{Compatibilità mobile}
	\label{fig:Compatibilità mobile}
\end{figure}
\subsection{Conclusioni}
Se realizzati per fare caching i Service Worker possono rendere la navigazione del sito web o dell'applicazione molto più veloce, senza rendere necessarie modifiche al sito o all'applicazione per raggiungere questo scopo. 
Purtroppo sono uno potente strumento anche per scopi malevoli, come illustrato al punto 4.4.
\newpage
\cleardoublepage
\section{Conclusioni}
La tesi ha mostrato come vi siano delle vulnerabilità nelle API web, prendendo un piccolo set di tre API, specificando per ognuna in modo approfondito una spiegazione generale, la sua struttura ed esempi pratici sui problemi di sicurezza e privacy.
-> finire 

\cleardoublepage
\listoffigures
\cleardoublepage
\section{Sitografia}
\begin{thebibliography}{99}
	%geolocation
	\bibitem{}
	Connorshea, Chris David Mills, HeilKing, northvanhooser, erikadoyle, fscholz, Alhadis, teoli, FabioMagnoni (2018),
	\emph{Features restricted to secure contexts, Mozilla Developer},
	\url{https://developer.mozilla.org/en-US/docs/Web/API/Geolocation}
	
	\bibitem{}
	heppy, Nisarg-Shah, tacsipacsi, chrisdavidmills, andysh, aneditor, smalllong, edent, divyanshu013, erikadoyle, VAggrippino, bsvensson, ewape, jpmedley, bjohnson, jsx, mugsydylan, Sebastianz, bizzybetz, shaneriley, atrama, nikifor, openjck, teoli, rebloor, Jeremie, jswisher, GARAAD, Zupper, jyz19880823, krishnachandra, markg, kohei.yoshino, kscarfone, SarahWalrus, BrandonLove, kmaglione, wlach, trevorh, ronj, ethertank, lmorchard, DavidWalsh, JohnKarahalis, mikerhodes, dflanagan, fcheslack, eberon, inma610, paul.irish, sebmozilla, dynamis, Steffen, stevep98, Dougt, Soupdragon, Chtitux, Bzbarsky
	\emph{Geolocation API, Mozilla Developer},
	\url{https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API}
	
	\bibitem{}
	W3C (2018), 
	\emph{Geolocation API Specification 2nd Edition},
	\url{https://www.w3.org/TR/geolocation-API/}
	
	\bibitem{}
	Ioannis Krontiris, Andreas Albers and Kai Rannenberg,
	\emph{W3C Geolocation API calls for
		Better User Privacy Protection}, 
	Chair of Mobile Business and Multilateral Security, Goethe University, Frankfurt, Germany
	
	\bibitem{}
	Doty, Nick, Mulligan, Deirdre K., Wilde, Erik (2010),
	\emph{Privacy Issues of the W3C Geolocation API}, UC Berkeley School of Information, \url{https://escholarship.org/uc/item/0rp834wf}
	
	\bibitem{}
	Ruadhán O'Donoghue (2013),
	\emph{HTML5 for the Mobile Web – a guide to the Geolocation API}, \url{https://mobiforge.com/design-development/html5-mobile-web-a-guide-geolocation-api}
	
	\bibitem{}
	OccupyTheWeb, WonderHowTo (2015),
	\emph{How to Find the Exact Location of Any IP Address}, \url{https://null-byte.wonderhowto.com/how-to/hack-like-pro-find-exact-location-any-ip-address-0161964/}
	
	\bibitem{}
	Kipkay(2017), 
	\emph{Trace Any IP Address}, \url{https://internet.gadgethacks.com/how-to/trace-any-ip-address-1916/}
	
	\bibitem{}
	Aurelio De Rosa (2014),
	\emph{An Introduction to the Geolocation API},
	\url{https://code.tutsplus.com/tutorials/an-introduction-to-the-geolocation-api--cms-20071}
	
	\bibitem{}
	Rafay Baloch, HTML5,
	\emph{HTML5 Modern Day Attack And Defense Vector},
	\url{http://www.xss-payloads.com/papers/HTML5AttackVectors.pdf}
	
	%payment request
	
	\bibitem{}
	Sheppy, poshaughnessy, jpmedley, echenley, chrisdavidmills, marcoscaceres, riking, amZotti, andersnorgaard, erikadoyle, agektmr, reaktivo, dgashmdn
	\emph{Payment Request API, Mozilla Developer},
	\url{https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API}
	
	\bibitem{}
	W3C (2018),
	\emph{W3C Payment Request API, Mozilla Developer},
	\url{https://w3c.github.io/payment-request/}
	
	\bibitem{}
	Natasja Bolton
	\emph{One more nail in the coffin for iFrames?}, 
	\url{https://sysnetgs.com/2016/06/one-nail-coffin-iframes/}
	
	\bibitem{}
	Matt Gaunt
	\emph{Deep Dive into the Payment Request API}, 
	\url{https://developers.google.com/web/fundamentals/payments/deep-dive-into-payment-request}
	
	\bibitem{}
	\emph{What is Payment Request?},
	\url{https://paymentrequest.show/}
	
	\bibitem{}
	\emph{Introduction to the Payment Request API},
	\url{https://developers.google.com/web/ilt/pwa/introduction-to-the-payment-request-api}
	
	\bibitem{}
	Eiji Kitamura,
	\emph{Bringing Easy and Fast Checkout with Payment Request API},
	\url{https://developers.google.com/web/updates/2016/07/payment-request}
	
	\bibitem{}
	Microsoft,
	\emph{Payment Request API},
	\url{https://docs.microsoft.com/en-us/microsoft-edge/dev-guide/windows-integration/payment-request-api}
	
	\bibitem{}
	Microsoft,
	\emph{Payment Request API samples},
	\url{https://developer.microsoft.com/en-us/microsoft-edge/testdrive/demos/paymentrequest/}
	
	\bibitem{}
	\emph{Simpler web payments: Introducing the Payment Request API},
	\url{https://blogs.windows.com/msedgedev/2016/12/15/payment-request-api-edge/#UATsm3ejAT9oYtrj.97}
	
	\bibitem{}
	Google Inc.(2018),
	\url{https://googlechrome.github.io/samples/paymentrequest/credit-cards/}
	
	%service worker
	\bibitem{}
	Angular University (2018),
	\emph{Angular Service Worker - Step-By-Step Guide for turning your Application into a PWA},
	\url{https://blog.angular-university.io/angular-service-worker/}
	
	\bibitem{}
	Angular University (),
	\emph{Service Workers - Practical Guided Introduction (several examples)},
	\url{https://blog.angular-university.io/service-workers/}
	
	\bibitem{}
	formatkaka, mfuji09, Jakubem, MichelleKwa12, Adrianjewell91, KateSturmey, tocretpa, danielpox, jpmedley, chrisdavidmills, akshayjai1, dchest, Sebastianz, neonstalwart, jaffathecake, mouki, Sheppy, Zanadar, fbender, DavidWalsh, fscholz, Heydon, teoli, rassoodock, Meggin (2018),
	\emph{Service Worker API},
	\url{https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API}
	
	\bibitem{}
	Throne3d, SphinxKnight, jcsahnwaldt, zekrom-vale, fscholz, arvindpdmn, Jiang-Xuan, wbamberg, schalkneethling, b2397, ramsunvtech, Jedipedia, khaled-hossain-code, mzur, anpa, armujahid, zeevmoney, Vectaio, parambirs, JonathanPool, rwaldron, 6112, kushdilip, thenable, hweeks, Jib, rousan, destin.moulton, Soupedenuit, teoli, ZeroUnderscoreOu, stephaniehobson, psl646, fbergr, atpollmann, kberov, jdsjs, booc0mtaco, programmer5000, otherrealm, kdex, CaemU, Granjow, david-mark, abeltanjq, fredmarques, torazaburo, halfzebra, natoen, tarungarg546, vladan1, igniteram, akshatkedia, nathanh, drostie, mamal, fearlessfool, MiLeung, PeteDevoy, RuiBottoFigueira, JonathanWatt, benjamingr, peter.kehl, ole, jacksonrayhamilton, arai, jmrog, jmsbrr, hltbra, jordanluyke, Sheppy, deisner, kamoroso94, dbruant, mdvorak, kristopolous@yahoo.com, pasqLisena, dstorey, bryanrsmith, nalindak, mattclaw, bitzstein, bgdavidx, Sebastianz, neeraj07rathi, kavitshah8, aochagavia, chrisdavidmills, Goldenyz, jpmedley, hexalys, Callmenorm, vinaygopinath, gaspard, slofurno, Jeremie, fkling42, zbuc, skeller88, miller.augusto, astorije, markg, jucrouzet, Delapouite, Gutworth, realityking, Chudesnov, Account, Fantasyshao, deltab., samvermillion, mnoorenberghe, jsantell, dentuzhik, Irving.Reid, Havvy, hthetiot, wesj, Olafk, DomenicDenicola
	\emph{Promise, Mozilla Developer}
	\url{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise}
	
	\bibitem{}
	DavidGuan, chrisdavidmills, Deleplace, jwhitlock, simon04, mrmaka, bmihelac, erikadoyle, YoranBrondsema, sideshowbarker, joshua1988, jpmedley, kberov, wbamberg, hl222ih, janx, karolklp, tomayac, maybe, UnJavaScripter, ebidel, JCE, philmander, termosa, franzy1709, stevemao, miguelmota, enguerran, allen.dean, fscholz, Brettz9, jryans, teoli, bhritchie, vrana, rippedspine, adria, Sheppy
	\emph{Using Service Workers, Mozilla Developer},
	\url{https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers}
	
	\bibitem{}
	W3C, Alex Russell, Jungkee Song, Jake Archibald, Marijn Kruisselbrink (2018),
	\emph{Service Workers Nightly},
	\url{https://w3c.github.io/ServiceWorker/}
	
	\bibitem{}
	Mozilla,
	\emph{Service Workers},
	\url{https://serviceworke.rs/}
	
	\bibitem{}
	Google Partners,
	\emph{Tecnologie web avanzate: Service worker},
	\url{https://support.google.com/partners/answer/7336697?hl=it}
	
	\bibitem{}
	Speedy Wordpress,
	\emph{Guida completa ai Service Worker Javascript},
	\url{https://www.speedywordpress.it/guida-completa-ai-service-worker-javascript/}
	
	\bibitem{}
	Matt Gaunt,
	\emph{Service Workers: an Introduction},
	\url{https://developers.google.com/web/fundamentals/primers/service-workers/}
	
	\bibitem{}
	SitePoint,
	\emph{Getting Started with Service Workers},
	\url{https://www.sitepoint.com/getting-started-with-service-workers/}
	
	\bibitem{}
	jakearchibald Github (2017),
	\emph{Service workers explained},
	\url{https://github.com/w3c/ServiceWorker/blob/master/explainer.md}
	
	\bibitem{}
	Lyza Danger Gardner
	\emph{Making A Service Worker: A Case Study}
	\url{https://www.smashingmagazine.com/2016/02/making-a-service-worker/}
	
	\bibitem{}
	Eshun Sharma
	\emph{An Introduction to Service Workers in JavaScript},
	\url{https://codeburst.io/an-introduction-to-service-workers-in-javascript-27d6376460c2}
	
	\bibitem{}
	Nicolas Bevacqua (2015), 
	\emph{Making a Simple Site Work Offline with ServiceWorker},
	\url{https://css-tricks.com/serviceworker-for-offline/}
	
	\bibitem{}
	\emph{Service Worker Security FAQ},
	\url{https://chromium.googlesource.com/chromium/src/+/lkcr/docs/security/service-worker-security-faq.md}
\end{thebibliography}
\end{document}